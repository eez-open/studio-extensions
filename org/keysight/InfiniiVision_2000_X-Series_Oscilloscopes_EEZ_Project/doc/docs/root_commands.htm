<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
   <title>Root (:) Commands</title><link rel="stylesheet" href="docbook_xsl_dds.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.70.1"><link rel="start" href="index.htm" title="Agilent InfiniiVision 2000&nbsp;X-Series Oscilloscopes"><link rel="up" href="index.htm" title="Agilent InfiniiVision 2000&nbsp;X-Series Oscilloscopes"><link rel="prev" href="_wai.htm" title="*WAI (Wait To Continue)"><link rel="next" href="_activity.htm" title=":ACTivity"><link rel="copyright" href="ln-warranty.htm" title="Warranty"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><p align="right"><a href="index.htm" style="text-decoration: none"><font size="1" color="#0099CC"><b>Agilent InfiniiVision 2000&nbsp;X-Series Oscilloscopes Programmer's Guide</b></font></a><br><hr noshade="true" color="#0099CC"></p><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="root_commands"></a>Root (:) Commands<a name="d0e11835"></a></h2></div></div></div><p>Control many of the basic functions of the oscilloscope and reside at
  the root level of the command tree. See <a href="root_commands.htm#root_commands_overview">Introduction to Root (:)
  Commands</a>.</p><div class="table"><a name="d0e11842"></a><p class="title"><b>Root (:) Commands Summary:</b></p><div class="table-contents"><table summary="Root (:) Commands Summary" cellspacing="0" cellpadding="5" width="100%" border="1"><colgroup><col><col><col></colgroup><thead valign="bottom"><tr><th align="left">Command</th><th align="left">Query</th><th align="left">Options and Query Returns</th></tr></thead><tbody valign="top"><tr><td><strong class="userinput"><code><a href="_activity.htm#_activity_command" title="Command Syntax">:ACTivity</a></code></strong></td><td><strong class="userinput"><code><a href="_activity.htm#_activity_query" title="Query Syntax">:ACTivity?</a></code></strong></td><td><p><strong class="userinput"><code>&lt;return value&gt; ::= &lt;edges&gt;,&lt;levels&gt;</code></strong></p><p><strong class="userinput"><code>&lt;edges&gt; ::= presence of edges (32-bit integer in NR1 format)</code></strong></p><p><strong class="userinput"><code>&lt;levels&gt; ::= logical highs or lows (32-bit integer in NR1 format)</code></strong></p></td></tr><tr><td><strong class="userinput"><code>n/a</code></strong></td><td><strong class="userinput"><code><a href="_aer.htm#_aer_query" title="Query Syntax">:AER?</a></code></strong></td><td><strong class="userinput"><code>{0 | 1}; an integer in NR1 format</code></strong></td></tr><tr><td><strong class="userinput"><code><a href="_autoscale.htm#_autoscale_command" title="Command Syntax">:AUToscale [&lt;source&gt;[,..,&lt;source&gt;]]</a></code></strong></td><td><strong class="userinput"><code>n/a</code></strong></td><td><p><strong class="userinput"><code>&lt;source&gt; ::= CHANnel&lt;n&gt; for DSO models</code></strong></p><p><strong class="userinput"><code>&lt;source&gt; ::= {CHANnel&lt;n&gt; | DIGital&lt;d&gt; | POD1 | POD2} for MSO models</code></strong></p><p><strong class="userinput"><code>&lt;source&gt; can be repeated up to 5 times</code></strong></p><p><strong class="userinput"><code>&lt;n&gt; ::= 1 to (# analog channels) in NR1 format</code></strong></p><p><strong class="userinput"><code>&lt;d&gt; ::= 0 to (# digital channels - 1) in NR1 format</code></strong></p></td></tr><tr><td><strong class="userinput"><code><a href="_autoscale_acquiremode.htm#_autoscale_acquiremode_command" title="Command Syntax">:AUToscale:AMODE &lt;value&gt;</a></code></strong></td><td><strong class="userinput"><code><a href="_autoscale_acquiremode.htm#_autoscale_acquiremode_query" title="Query Syntax">:AUToscale:AMODE?</a></code></strong></td><td><strong class="userinput"><code>&lt;value&gt; ::= {NORMal | CURRent}}</code></strong></td></tr><tr><td><strong class="userinput"><code><a href="_autoscale_channels.htm#_autoscale_channels_command" title="Command Syntax">:AUToscale:CHANnels &lt;value&gt;</a></code></strong></td><td><strong class="userinput"><code><a href="_autoscale_channels.htm#_autoscale_channels_query" title="Query Syntax">:AUToscale:CHANnels?</a></code></strong></td><td><strong class="userinput"><code>&lt;value&gt; ::= {ALL | DISPlayed}}</code></strong></td></tr><tr><td><strong class="userinput"><code><a href="_autoscale_fdebug.htm#_autoscale_fdebug_command" title="Command Syntax">:AUToscale:FDEBug {{0 | OFF} | {1 | ON}}</a></code></strong></td><td><strong class="userinput"><code><a href="_autoscale_fdebug.htm#_autoscale_fdebug_query" title="Query Syntax">:AUToscale:FDEBug?</a></code></strong></td><td><p><strong class="userinput"><code>{0 | 1}</code></strong></p></td></tr><tr><td><strong class="userinput"><code><a href="_blank.htm#_blank_command" title="Command Syntax">:BLANk [&lt;source&gt;]</a></code></strong></td><td><strong class="userinput"><code>n/a</code></strong></td><td><p><strong class="userinput"><code>&lt;source&gt; ::= {CHANnel&lt;n&gt;} | FUNCtion | MATH | SBUS1 | WMEMory&lt;r&gt;} for DSO models</code></strong></p><p><strong class="userinput"><code>&lt;source&gt; ::= {CHANnel&lt;n&gt; | DIGital&lt;d&gt; | POD{1 | 2} | BUS{1 | 2} | FUNCtion | MATH | SBUS1 | WMEMory&lt;r&gt;} for MSO models</code></strong></p><p><strong class="userinput"><code>&lt;n&gt; ::= 1 to (# analog channels) in NR1 format</code></strong></p><p><strong class="userinput"><code>&lt;d&gt; ::= 0 to (# digital channels - 1) in NR1 format</code></strong></p><p><strong class="userinput"><code>&lt;r&gt; ::= 1 to (# ref waveforms) in NR1 format</code></strong></p></td></tr><tr><td><strong class="userinput"><code><a href="_digitize.htm#_digitize_command" title="Command Syntax">:DIGitize [&lt;source&gt;[,..,&lt;source&gt;]]</a></code></strong></td><td><strong class="userinput"><code>n/a</code></strong></td><td><p><strong class="userinput"><code>&lt;source&gt; ::= {CHANnel&lt;n&gt; | FUNCtion | MATH} for DSO models</code></strong></p><p><strong class="userinput"><code>&lt;source&gt; ::= {CHANnel&lt;n&gt; | DIGital&lt;d&gt; | POD{1 | 2} | BUS{1 | 2} | FUNCtion | MATH} for MSO models</code></strong></p><p><strong class="userinput"><code>&lt;source&gt; can be repeated up to 5 times</code></strong></p><p><strong class="userinput"><code>&lt;n&gt; ::= 1 to (# analog channels) in NR1 format</code></strong></p><p><strong class="userinput"><code>&lt;d&gt; ::= 0 to (# digital channels - 1) in NR1 format</code></strong></p></td></tr><tr><td><strong class="userinput"><code><a href="_mteenable.htm#_mteenable_command" title="Command Syntax">:MTEenable &lt;n&gt;</a></code></strong></td><td><strong class="userinput"><code><a href="_mteenable.htm#_mteenable_query" title="Query Syntax">:MTEenable?</a></code></strong></td><td><strong class="userinput"><code>&lt;n&gt; ::= 16-bit integer in NR1 format</code></strong></td></tr><tr><td><strong class="userinput"><code>n/a</code></strong></td><td><strong class="userinput"><code><a href="_mteregister_event.htm#_mteregister_event_query" title="Query Syntax">:MTERegister[:EVENt]?</a></code></strong></td><td><strong class="userinput"><code>&lt;n&gt; ::= 16-bit integer in NR1 format</code></strong></td></tr><tr><td><strong class="userinput"><code><a href="_opee.htm#_opee_command" title="Command Syntax">:OPEE &lt;n&gt;</a></code></strong></td><td><strong class="userinput"><code><a href="_opee.htm#_opee_query" title="Query Syntax">:OPEE?</a></code></strong></td><td><strong class="userinput"><code>&lt;n&gt; ::= 15-bit integer in NR1 format</code></strong></td></tr><tr><td><strong class="userinput"><code>n/a</code></strong></td><td><strong class="userinput"><code><a href="_operegister_condition.htm#_operegister_condition_query" title="Query Syntax">:OPERregister:CONDition?</a></code></strong></td><td><strong class="userinput"><code>&lt;n&gt; ::= 15-bit integer in NR1 format</code></strong></td></tr><tr><td><strong class="userinput"><code>n/a</code></strong></td><td><strong class="userinput"><code><a href="_operegister_event.htm#_operegister_event_query" title="Query Syntax">:OPERegister[:EVENt]?</a></code></strong></td><td><strong class="userinput"><code>&lt;n&gt; ::= 15-bit integer in NR1 format</code></strong></td></tr><tr><td><strong class="userinput"><code><a href="_ovlenable.htm#_ovlenable_command" title="Command Syntax">:OVLenable &lt;mask&gt;</a></code></strong></td><td><strong class="userinput"><code><a href="_ovlenable.htm#_ovlenable_query" title="Query Syntax">:OVLenable?</a></code></strong></td><td><p><strong class="userinput"><code>&lt;mask&gt; ::= 16-bit integer in NR1 format as shown:</code></strong></p><pre class="synopsis">Bit Weight Input
--- ------ ----------
10   1024  Ext Trigger Fault
 9    512  Channel 4 Fault
 8    256  Channel 3 Fault
 7    128  Channel 2 Fault
 6     64  Channel 1 Fault
 4     16  Ext Trigger OVL
 3      8  Channel 4 OVL
 2      4  Channel 3 OVL
 1      2  Channel 2 OVL
 0      1  Channel 1 OVL</pre></td></tr><tr><td><strong class="userinput"><code>n/a</code></strong></td><td><strong class="userinput"><code><a href="_ovlregister.htm#_ovlregister_query" title="Query Syntax">:OVLRegister?</a></code></strong></td><td><strong class="userinput"><code>&lt;value&gt; ::= integer in NR1 format. See OVLenable for &lt;value&gt;</code></strong></td></tr><tr><td><strong class="userinput"><code><a href="_print.htm#_print_command" title="Command Syntax">:PRINt [&lt;options&gt;]</a></code></strong></td><td><strong class="userinput"><code>n/a</code></strong></td><td><p><strong class="userinput"><code>&lt;options&gt; ::= [&lt;print option&gt;][,..,&lt;print option&gt;]</code></strong></p><p><strong class="userinput"><code>&lt;print option&gt; ::= {COLor | GRAYscale | PRINter0 | PRINter1 | BMP8bit | BMP | PNG | NOFactors | FACTors}</code></strong></p><p><strong class="userinput"><code>&lt;print option&gt; can be repeated up to 5 times.</code></strong></p></td></tr><tr><td><strong class="userinput"><code><a href="_run.htm#_run_command" title="Command Syntax">:RUN</a></code></strong></td><td><strong class="userinput"><code>n/a</code></strong></td><td><strong class="userinput"><code>n/a</code></strong></td></tr><tr><td><strong class="userinput"><code>n/a</code></strong></td><td><strong class="userinput"><code><a href="_serial.htm#_serial_query" title="Query Syntax">:SERial</a></code></strong></td><td><strong class="userinput"><code>&lt;return value&gt; ::= unquoted string containing serial number</code></strong></td></tr><tr><td><strong class="userinput"><code><a href="_single.htm#_single_command" title="Command Syntax">:SINGle</a></code></strong></td><td><strong class="userinput"><code>n/a</code></strong></td><td><strong class="userinput"><code>n/a</code></strong></td></tr><tr><td><strong class="userinput"><code>n/a</code></strong></td><td><strong class="userinput"><code><a href="_status.htm#_status_query" title="Query Syntax">:STATus? &lt;display&gt;</a></code></strong></td><td><p><strong class="userinput"><code>{0 | 1}</code></strong></p><p><strong class="userinput"><code>&lt;display&gt; ::= {CHANnel&lt;n&gt; | DIGital&lt;d&gt; | POD{1 | 2} | BUS{1 | 2} | FUNCtion | MATH | SBUS1 | WMEMory&lt;r&gt;}</code></strong></p><p><strong class="userinput"><code>&lt;n&gt; ::= 1 to (# analog channels) in NR1 format</code></strong></p><p><strong class="userinput"><code>&lt;d&gt; ::= 0 to (# digital channels - 1) in NR1 format</code></strong></p><p><strong class="userinput"><code>&lt;r&gt; ::= 1 to (# ref waveforms) in NR1 format</code></strong></p></td></tr><tr><td><strong class="userinput"><code><a href="_stop.htm#_stop_command" title="Command Syntax">:STOP</a></code></strong></td><td><strong class="userinput"><code>n/a</code></strong></td><td><strong class="userinput"><code>n/a</code></strong></td></tr><tr><td><strong class="userinput"><code>n/a</code></strong></td><td><strong class="userinput"><code><a href="_ter.htm#_ter_query" title="Query Syntax">:TER?</a></code></strong></td><td><strong class="userinput"><code>{0 | 1}</code></strong></td></tr><tr><td><strong class="userinput"><code><a href="_view.htm#_view_command" title="Command Syntax">:VIEW &lt;source&gt;</a></code></strong></td><td><strong class="userinput"><code>n/a</code></strong></td><td><p><strong class="userinput"><code>&lt;source&gt; ::= {CHANnel&lt;n&gt; | FUNCtion | MATH | SBUS1 | WMEMory&lt;r&gt;} for DSO models</code></strong></p><p><strong class="userinput"><code>&lt;source&gt; ::= {CHANnel&lt;n&gt; | DIGital&lt;d&gt; | POD{1 | 2} | BUS{1 | 2} | FUNCtion | MATH | SBUS1 | WMEMory&lt;r&gt;} for MSO models</code></strong></p><p><strong class="userinput"><code>&lt;n&gt; ::= 1 to (# analog channels) in NR1 format</code></strong></p><p><strong class="userinput"><code>&lt;d&gt; ::= 0 to (# digital channels - 1) in NR1 format</code></strong></p><p><strong class="userinput"><code>&lt;r&gt; ::= 1 to (# ref waveforms) in NR1 format</code></strong></p></td></tr></tbody></table></div></div><br class="table-break"><h2><a name="root_commands_overview"></a>Introduction to Root (:)
  Commands</h2><p><a name="d0e12204"></a><a name="d0e12207"></a><a name="d0e12210"></a><a name="d0e12213"></a>Root level commands control many of the basic operations of
  the instrument. These commands are always recognized by the parser if they
  are prefixed with a colon, regardless of current command tree position.
  After executing a root-level command, the parser is positioned at the root
  of the command tree.</p></div></body></html>